{"version":3,"file":"ts-enums.umd.js","sources":["../src/ts-enums.ts"],"sourcesContent":["const INITIALIZED: symbol = Symbol();\r\n\r\n/**\r\n * An instance of the enum (for example, if you have an enumeration of seasons,\r\n * Winter would be an EnumValue.\r\n */\r\nexport abstract class EnumValue {\r\n  private static sizes: Map<Function, number> = new Map<Function, number>();\r\n  private readonly _ordinal: number; // set in Enum.enumValuesFromObject\r\n  private _propName: string; // set in Enum.enumValuesFromObject\r\n\r\n  /**\r\n   * `initEnum()` on Enum closes the class, so subsequent calls to this\r\n   * constructor throw an exception.\r\n   */\r\n  constructor(private _description: string) {\r\n    if ({}.hasOwnProperty.call(new.target, INITIALIZED)) {\r\n      throw new Error('EnumValue classes canâ€™t be instantiated individually');\r\n    }\r\n    // keep track of the number of instances that have been created,\r\n    // and use it to set the ordinal\r\n    let size: number | undefined = EnumValue.sizes.get(this.constructor);\r\n    if (!size) {\r\n      size = 0;\r\n    }\r\n    this._ordinal = size;\r\n    size++;\r\n    EnumValue.sizes.set(this.constructor, size);\r\n  }\r\n\r\n  /**\r\n   * The description of the instance passed into the constructor - may be the\r\n   * same as the propName.\r\n   *\r\n   * @returns {string} The description\r\n   */\r\n  get description(): string {\r\n    return this._description;\r\n  }\r\n\r\n  toString() {\r\n    return `${this.constructor.name}.${this.propName}`;\r\n  }\r\n\r\n  /**\r\n   * Returns the index of the instance in the enum (0-based)\r\n   *\r\n   * @returns {number} The index of the instance in the enum (0-based)\r\n   */\r\n  get ordinal(): number {\r\n    return this._ordinal;\r\n  }\r\n\r\n  /**\r\n   * Returns the property name used for this instance in the Enum.\r\n   *\r\n   * @returns {string} the property name used for this instance in the Enum\r\n   */\r\n  get propName(): string {\r\n    return this._propName;\r\n  }\r\n}\r\n\r\n/**\r\n * This is an abstract class that is not intended to be used directly. Extend it\r\n * to turn your class into an enum (initialization is performed via\r\n * `this.initEnum()` within the constructor).\r\n */\r\nexport abstract class Enum<T extends EnumValue> {\r\n  private static enumValues: Map<string, EnumValue[]> = new Map<\r\n    string,\r\n    EnumValue[]\r\n  >();\r\n  private name: string;\r\n\r\n  /**\r\n   * Set up the enum and close the class. This must be called after the\r\n   * constructor to set up the logic.\r\n   *\r\n   * @param name The name that will be used for internal storage - must be\r\n   * unique\r\n   * @param theEnum The enum to process\r\n   */\r\n  private static initEnum<T extends EnumValue>(\r\n    name: string,\r\n    theEnum: Enum<T>\r\n  ): void {\r\n    if (Enum.enumValues.has(theEnum.name)) {\r\n      throw new Error(`Duplicate name: ${theEnum.name}`);\r\n    }\r\n    let enumValues: T[] = this.enumValuesFromObject(theEnum);\r\n    Object.freeze(theEnum);\r\n    Enum.enumValues.set(theEnum.name, enumValues);\r\n  }\r\n\r\n  /**\r\n   * Extract the enumValues from the Enum. We set the ordinal and propName\r\n   * properties on the EnumValue. We also freeze the objects and lock the Enum\r\n   * and EnumValue to prevent future instantiation.\r\n   *\r\n   * @param theEnum The enum to process\r\n   * @returns {T[]} The array of EnumValues\r\n   */\r\n  private static enumValuesFromObject<T extends EnumValue>(\r\n    theEnum: Enum<T>\r\n  ): T[] {\r\n    const values: T[] = Object.getOwnPropertyNames(theEnum)\r\n      .filter((propName: string) => theEnum[propName] instanceof EnumValue)\r\n      .map((propName: string) => {\r\n        const enumValue: T = theEnum[propName];\r\n        Object.defineProperty(enumValue, '_propName', {\r\n          value: propName,\r\n          configurable: false,\r\n          writable: false,\r\n          enumerable: true\r\n        });\r\n        Object.freeze(enumValue);\r\n        return enumValue;\r\n      });\r\n    if (values.length) {\r\n      values[0].constructor[INITIALIZED] = true;\r\n    }\r\n\r\n    let descriptions: string[] = values.map(\r\n      (value: T): string => value.description\r\n    );\r\n    if (values.length !== this.unique(descriptions).length) {\r\n      throw new Error(\r\n        'All descriptions must be unique for a given enum type.' +\r\n          `Instead, there are multiples in ${theEnum.name}`\r\n      );\r\n    }\r\n    return values;\r\n  }\r\n\r\n  /**\r\n   * Extract the unique values from an array. Based on \r\n   * https://stackoverflow.com/a/23282057.\r\n   */\r\n  private static unique<T>(values: T[]): T[] {\r\n    return values.filter((value: T, i: number) => values.indexOf(value) === i);\r\n  }\r\n\r\n  private static values(name: string): EnumValue[] {\r\n    let values: EnumValue[] | undefined = this.enumValues.get(name);\r\n    return values ? [...values] : [];\r\n  }\r\n\r\n  /**\r\n   * Given the property name of an enum constant, return its value.\r\n   *\r\n   * @param propName The property name to search by\r\n   * @returns {undefined|T} The matching instance\r\n   */\r\n  byPropName(propName: string): T | undefined {\r\n    return this.values.find((x: T) => x.propName === propName);\r\n  }\r\n\r\n  /**\r\n   * Given the description of an enum constant, return its value.\r\n   *\r\n   * @param description The property name to search by\r\n   * @returns {undefined|T} The matching instance\r\n   */\r\n  byDescription(description: string): T | undefined {\r\n    return this.values.find((x: T) => x.description === description);\r\n  }\r\n\r\n  /**\r\n   * Return a defensively-copied array of all the elements of the enum.\r\n   *\r\n   * @returns {T[]} The array of EnumValues\r\n   */\r\n  get values(): T[] {\r\n    return Enum.values(this.name) as T[];\r\n  }\r\n\r\n  /**\r\n   * Returns a simple representation of the type.\r\n   *\r\n   * @returns {string} a simple representation of the type\r\n   */\r\n  toString(): string {\r\n    return this.name;\r\n  }\r\n\r\n  /**\r\n   * Set up the enum and close the class.\r\n   *\r\n   * @param name The name that will be used for internal storage - must be unique\r\n   */\r\n  protected initEnum(name: string): void {\r\n    this.name = name;\r\n    Enum.initEnum(name, this);\r\n  }\r\n}\r\n"],"names":[],"mappings":";;;;;;AAAA,IAAM,WAAW,GAAW,MAAM,EAAE,CAAC;;;;;AAMrC;;;;;IASE,mBAAoB,YAAoB;;QAApB,iBAAY,GAAZ,YAAY,CAAQ;QACtC,IAAI,EAAE,CAAC,cAAc,CAAC,IAAI,aAAa,WAAW,CAAC,EAAE;YACnD,MAAM,IAAI,KAAK,CAAC,sDAAsD,CAAC,CAAC;SACzE;;;QAGD,IAAI,IAAI,GAAuB,SAAS,CAAC,KAAK,CAAC,GAAG,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;QACrE,IAAI,CAAC,IAAI,EAAE;YACT,IAAI,GAAG,CAAC,CAAC;SACV;QACD,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC;QACrB,IAAI,EAAE,CAAC;QACP,SAAS,CAAC,KAAK,CAAC,GAAG,CAAC,IAAI,CAAC,WAAW,EAAE,IAAI,CAAC,CAAC;KAC7C;IAQD,sBAAI,kCAAW;;;;;;;aAAf;YACE,OAAO,IAAI,CAAC,YAAY,CAAC;SAC1B;;;OAAA;IAED,4BAAQ,GAAR;QACE,OAAU,IAAI,CAAC,WAAW,CAAC,IAAI,SAAI,IAAI,CAAC,QAAU,CAAC;KACpD;IAOD,sBAAI,8BAAO;;;;;;aAAX;YACE,OAAO,IAAI,CAAC,QAAQ,CAAC;SACtB;;;OAAA;IAOD,sBAAI,+BAAQ;;;;;;aAAZ;YACE,OAAO,IAAI,CAAC,SAAS,CAAC;SACvB;;;OAAA;IArDc,eAAK,GAA0B,IAAI,GAAG,EAAoB,CAAC;IAsD5E,gBAAC;CAAA,IAAA;AAED;;;;;AAKA;IAAA;KA+HC;;;;;;;;;IAhHgB,aAAQ,GAAvB,UACE,IAAY,EACZ,OAAgB;QAEhB,IAAI,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,OAAO,CAAC,IAAI,CAAC,EAAE;YACrC,MAAM,IAAI,KAAK,CAAC,qBAAmB,OAAO,CAAC,IAAM,CAAC,CAAC;SACpD;QACD,IAAI,UAAU,GAAQ,IAAI,CAAC,oBAAoB,CAAC,OAAO,CAAC,CAAC;QACzD,MAAM,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC;QACvB,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,OAAO,CAAC,IAAI,EAAE,UAAU,CAAC,CAAC;KAC/C;;;;;;;;;IAUc,yBAAoB,GAAnC,UACE,OAAgB;QAEhB,IAAM,MAAM,GAAQ,MAAM,CAAC,mBAAmB,CAAC,OAAO,CAAC;aACpD,MAAM,CAAC,UAAC,QAAgB,IAAK,OAAA,OAAO,CAAC,QAAQ,CAAC,YAAY,SAAS,GAAA,CAAC;aACpE,GAAG,CAAC,UAAC,QAAgB;YACpB,IAAM,SAAS,GAAM,OAAO,CAAC,QAAQ,CAAC,CAAC;YACvC,MAAM,CAAC,cAAc,CAAC,SAAS,EAAE,WAAW,EAAE;gBAC5C,KAAK,EAAE,QAAQ;gBACf,YAAY,EAAE,KAAK;gBACnB,QAAQ,EAAE,KAAK;gBACf,UAAU,EAAE,IAAI;aACjB,CAAC,CAAC;YACH,MAAM,CAAC,MAAM,CAAC,SAAS,CAAC,CAAC;YACzB,OAAO,SAAS,CAAC;SAClB,CAAC,CAAC;QACL,IAAI,MAAM,CAAC,MAAM,EAAE;YACjB,MAAM,CAAC,CAAC,CAAC,CAAC,WAAW,CAAC,WAAW,CAAC,GAAG,IAAI,CAAC;SAC3C;QAED,IAAI,YAAY,GAAa,MAAM,CAAC,GAAG,CACrC,UAAC,KAAQ,IAAa,OAAA,KAAK,CAAC,WAAW,GAAA,CACxC,CAAC;QACF,IAAI,MAAM,CAAC,MAAM,KAAK,IAAI,CAAC,MAAM,CAAC,YAAY,CAAC,CAAC,MAAM,EAAE;YACtD,MAAM,IAAI,KAAK,CACb,wDAAwD;iBACtD,qCAAmC,OAAO,CAAC,IAAM,CAAA,CACpD,CAAC;SACH;QACD,OAAO,MAAM,CAAC;KACf;;;;;IAMc,WAAM,GAArB,UAAyB,MAAW;QAClC,OAAO,MAAM,CAAC,MAAM,CAAC,UAAC,KAAQ,EAAE,CAAS,IAAK,OAAA,MAAM,CAAC,OAAO,CAAC,KAAK,CAAC,KAAK,CAAC,GAAA,CAAC,CAAC;KAC5E;IAEc,WAAM,GAArB,UAAsB,IAAY;QAChC,IAAI,MAAM,GAA4B,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;QAChE,OAAO,MAAM,GAAO,MAAM,WAAI,EAAE,CAAC;KAClC;;;;;;;IAQD,yBAAU,GAAV,UAAW,QAAgB;QACzB,OAAO,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,UAAC,CAAI,IAAK,OAAA,CAAC,CAAC,QAAQ,KAAK,QAAQ,GAAA,CAAC,CAAC;KAC5D;;;;;;;IAQD,4BAAa,GAAb,UAAc,WAAmB;QAC/B,OAAO,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,UAAC,CAAI,IAAK,OAAA,CAAC,CAAC,WAAW,KAAK,WAAW,GAAA,CAAC,CAAC;KAClE;IAOD,sBAAI,wBAAM;;;;;;aAAV;YACE,OAAO,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,CAAQ,CAAC;SACtC;;;OAAA;;;;;;IAOD,uBAAQ,GAAR;QACE,OAAO,IAAI,CAAC,IAAI,CAAC;KAClB;;;;;;IAOS,uBAAQ,GAAlB,UAAmB,IAAY;QAC7B,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;QACjB,IAAI,CAAC,QAAQ,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;KAC3B;IA7Hc,eAAU,GAA6B,IAAI,GAAG,EAG1D,CAAC;IA2HN,WAAC;CAAA,IAAA;;;;;;;"}